{
    "c_cpp.debuggers.pipeTransport.description": "当存在时，这会告诉调试器使用另一个可执行文件作为管道连接到远程计算机，该管道将标准输入/输出在 VS Code 和启用 MI 的调试器后端可执行文件（如 gdb）之间中继。",
    "c_cpp.debuggers.pipeTransport.default.pipeProgram": "输入管道程序名称的完整路径，例如 '/usr/bin/ssh'。",
    "c_cpp.debuggers.pipeTransport.default.debuggerPath": "目标机器上调试器的完整路径，例如 /usr/bin/gdb。",
    "c_cpp.debuggers.pipeTransport.debuggerPath.description": "目标机器上调试器的完整路径，例如 /usr/bin/gdb。",
    "c_cpp.debuggers.pipeTransport.pipeCwd.description": "管道程序的工作目录的完整路径。",
    "c_cpp.debuggers.pipeTransport.pipeProgram.description": "要执行的完整管道命令。",
    "c_cpp.debuggers.pipeTransport.pipeArgs.description": "传递给管道程序的命令行参数以配置连接。",
    "c_cpp.debuggers.pipeTransport.pipeEnv.description": "传递给管道程序的环境变量。",
    "c_cpp.debuggers.pipeTransport.quoteArgs.description": "如果 pipeProgram 的各个参数包含字符（如空格或制表符），是否应将其引用？如果为 'false'，则调试器命令将不再自动引用。默认值为 'true'。",
    "c_cpp.debuggers.logging.description": "可选标志，用于确定应记录到调试控制台的消息类型。",
    "c_cpp.debuggers.logging.exceptions.description": "可选标志，用于确定是否应将异常消息记录到调试控制台。默认值为 true。",
    "c_cpp.debuggers.logging.moduleLoad.description": "可选标志，用于确定是否应将模块加载事件记录到调试控制台。默认值为 true。",
    "c_cpp.debuggers.logging.programOutput.description": "可选标志，用于确定是否应将程序输出记录到调试控制台。默认值为 true。",
    "c_cpp.debuggers.logging.engineLogging.description": "可选标志，用于确定是否应将诊断调试引擎消息记录到调试控制台。默认值为 false。",
    "c_cpp.debuggers.logging.trace.description": "可选标志，用于确定是否应将诊断适配器命令跟踪记录到调试控制台。默认值为 false。",
    "c_cpp.debuggers.logging.traceResponse.description": "可选标志，用于确定是否应将诊断适配器命令和响应跟踪记录到调试控制台。默认值为 false。",
    "c_cpp.debuggers.cppvsdbg.logging.threadExit.description": "可选标志，用于确定是否应将线程退出消息记录到调试控制台。默认值：false。",
    "c_cpp.debuggers.cppvsdbg.logging.processExit.description": "可选标志，用于确定是否应将目标进程退出消息记录到调试控制台。默认值：true。",
    "c_cpp.debuggers.text.description": "要执行的调试器命令。",
    "c_cpp.debuggers.description.description": "命令的可选描述。",
    "c_cpp.debuggers.ignoreFailures.description": "如果为 true，则应忽略命令的失败。默认值为 false。",
    "c_cpp.debuggers.program.description": "程序可执行文件的完整路径。",
    "c_cpp.debuggers.args.description": "传递给程序的命令行参数。",
    "c_cpp.debuggers.cppdbg.type.description": "引擎的类型。必须是 \"cppdbg\"。",
    "c_cpp.debuggers.cppvsdbg.type.description": "引擎的类型。必须是 \"cppvsdbg\"。",
    "c_cpp.debuggers.targetArchitecture.description": "被调试程序的架构。除非设置此参数，否则将自动检测。允许的值有 x86、arm、arm64、mips、x64、amd64、x86_64。",
    "c_cpp.debuggers.cwd.description": "目标的工作目录。",
    "c_cpp.debuggers.setupCommands.description": "用于设置底层调试器的一个或多个 GDB/LLDB 命令。例如：\"setupCommands\": [ { \"text\": \"-enable-pretty-printing\", \"description\": \"启用 GDB 美化打印\", \"ignoreFailures\": true } ]。",
    "c_cpp.debuggers.postRemoteConnectCommands.description": "连接到调试服务器后执行的一个或多个命令。",
    "c_cpp.debuggers.customLaunchSetupCommands.description": "如果提供，这将用其他命令替换用于启动目标的默认命令。例如，这可以是 \"-target-attach\" 以附加到目标进程。空命令列表将启动命令替换为空，这在调试器作为命令行选项提供启动选项时很有用。例如：\"customLaunchSetupCommands\": [ { \"text\": \"target-run\", \"description\": \"运行目标\", \"ignoreFailures\": false } ]。",
    "c_cpp.debuggers.launchCompleteCommand.description": "调试器完全设置后执行的命令，以使目标进程运行。允许的值有 \"exec-run\"、\"exec-continue\"、\"None\"。默认值为 \"exec-run\"。",
    "c_cpp.debuggers.cppdbg.visualizerFile.description": "调试此进程时使用的 .natvis 文件。此选项与 GDB 美化打印不兼容。如果使用此设置，请参阅 \"showDisplayString\"。",
    "c_cpp.debuggers.cppdbg.svdPath.description": "嵌入式设备的 SVD 文件的完整路径。",
    "c_cpp.debuggers.cppvsdbg.visualizerFile.description": "调试此进程时使用的 .natvis 文件。",
    "c_cpp.debuggers.showDisplayString.description": "指定 visualizerFile 时，showDisplayString 将启用显示字符串。启用此选项可能会导致调试期间性能较慢。",
    "c_cpp.debuggers.environment.description": "要添加到程序环境中的环境变量。例如：[ { \"name\": \"config\", \"value\": \"Debug\" } ]，而不是 [ { \"config\": \"Debug\" } ]。",
    "c_cpp.debuggers.envFile.description": "包含环境变量定义的文件的绝对路径。此文件每行有一个用等号分隔的键值对。例如：KEY=VALUE。",
    "c_cpp.debuggers.additionalSOLibSearchPath.description": "用于搜索 .so 文件的目录的分号分隔列表。例如：\"c:\\dir1;c:\\dir2\"。",
    "c_cpp.debuggers.MIMode.description": "指示 MIDebugEngine 将连接到的控制台调试器。允许的值有 \"gdb\"、\"lldb\"。",
    "c_cpp.debuggers.miDebuggerPath.description": "MI 调试器（如 gdb）的路径。如果未指定，它将首先搜索路径中的调试器。",
    "c_cpp.debuggers.miDebuggerArgs.description": "MI 调试器（如 gdb）的附加参数。",
    "c_cpp.debuggers.miDebuggerServerAddress.description": "要连接的 MI 调试器服务器的网络地址（例如：localhost:1234）。",
    "c_cpp.debuggers.useExtendedRemote.description": "使用 target extended-remote 模式连接到 MI 调试器服务器。",
    "c_cpp.debuggers.stopAtEntry.description": "可选参数。如果为 true，调试器应在目标的入口点停止。如果传递了 processId，则无效。",
    "c_cpp.debuggers.debugServerPath.description": "要启动的调试服务器的可选完整路径。默认为 null。它与 \"miDebugServerAddress\" 或您自己的服务器的 \"customSetupCommand\" 一起使用，该命令运行 \"-target-select remote <server:port>\"。",
    "c_cpp.debuggers.debugServerArgs.description": "调试服务器的可选参数。默认为 null。",
    "c_cpp.debuggers.serverStarted.description": "在调试服务器输出中查找的可选服务器启动模式。默认为 null。",
    "c_cpp.debuggers.filterStdout.description": "在 stdout 流中搜索服务器启动模式，并将 stdout 记录到调试输出。默认值为 true。",
    "c_cpp.debuggers.filterStderr.description": "在 stderr 流中搜索服务器启动模式，并将 stderr 记录到调试输出。默认值为 false。",
    "c_cpp.debuggers.serverLaunchTimeout.description": "调试器等待调试服务器启动的可选时间（以毫秒为单位）。默认值为 10000。",
    "c_cpp.debuggers.coreDumpPath.description": "指定程序的核心转储文件的可选完整路径。默认为 null。",
    "c_cpp.debuggers.cppdbg.externalConsole.description": "如果为 true，则为被调试程序启动一个控制台。如果为 false，在 Linux 和 Windows 上，它将出现在集成控制台中。",
    "c_cpp.debuggers.cppvsdbg.externalConsole.description": "[已被 'console' 废弃] 如果为 true，则为被调试程序启动一个控制台。如果为 false，则不启动控制台。",
    "c_cpp.debuggers.cppvsdbg.console.description": "在何处启动调试目标。如果未定义，默认为 'internalConsole'。",
    "c_cpp.debuggers.cppvsdbg.console.internalConsole.description": "输出到 VS Code 调试控制台。这不支持读取控制台输入（例如：'std::cin' 或 'scanf'）。",
    "c_cpp.debuggers.cppvsdbg.console.integratedTerminal.description": "VS Code 的集成终端。",
    "c_cpp.debuggers.cppvsdbg.console.externalTerminal.description": "控制台应用程序将在外部终端窗口中启动。在重新启动场景中将重用窗口，并且在应用程序退出时不会自动消失。",
    "c_cpp.debuggers.cppvsdbg.console.newExternalWindow.description": "控制台应用程序将在其自己的外部控制台窗口中启动，当应用程序停止时该窗口将结束。非控制台应用程序将在没有终端的情况下运行，stdout/stderr 将被忽略。",
    "c_cpp.debuggers.avoidWindowsConsoleRedirection.description": "如果为 true，则禁用调试器控制台重定向，这对于集成终端支持是必需的。",
    "c_cpp.debuggers.sourceFileMap.description": "传递给调试引擎的可选源文件映射。例如：'{ \"/original/source/path\":\"/current/source/path\" }'。",
    "c_cpp.debuggers.processId.anyOf.description": "要附加调试器的可选进程 ID。使用 \"${command:pickProcess}\" 获取要附加的本地运行进程列表。请注意，某些平台需要管理员权限才能附加到进程。",
    "c_cpp.debuggers.symbolSearchPath.description": "用于搜索符号（即 pdb）文件的目录的分号分隔列表。例如：\"c:\\dir1;c:\\dir2\"。",
    "c_cpp.debuggers.dumpPath.description": "指定程序的转储文件的可选完整路径。例如：\"c:\\temp\\app.dmp\"。默认为 null。",
    "c_cpp.debuggers.enableDebugHeap.description": "如果为 false，则进程将禁用调试堆启动。这会将环境变量 '_NO_DEBUG_HEAP' 设置为 '1'。",
    "c_cpp.debuggers.symbolLoadInfo.description": "符号加载的显式控制。",
    "c_cpp.debuggers.symbolLoadInfo.loadAll.description": "如果为 true，将加载所有库的符号，否则将不加载任何 solib 符号。默认值为 true。",
    "c_cpp.debuggers.symbolLoadInfo.exceptionList.description": "文件名列表（允许使用通配符）用分号 ';' 分隔。修改 LoadAll 的行为。如果 LoadAll 为 true，则不加载与列表中任何名称匹配的库的符号。否则，仅加载与匹配的库的符号。例如：\"foo.so;bar.so\"。",
    "c_cpp.debuggers.requireExactSource.description": "可选标志，要求当前源代码与 pdb 匹配。",
    "c_cpp.debuggers.stopAtConnect.description": "如果为 true，调试器在连接到目标后应停止。如果为 false，调试器在连接后将继续。默认值为 false。",
    "c_cpp.debuggers.hardwareBreakpoints.description": "远程目标的硬件断点行为的显式控制。",
    "c_cpp.debuggers.hardwareBreakpoints.require.description": "如果为 true，总是使用硬件断点。默认值为 false。",
    "c_cpp.debuggers.hardwareBreakpoints.limit.description": "可选的硬件断点数量限制。仅在 \"require\" 为 true 且 \"limit\" 大于 0 时强制执行。默认值为 0。",
    "c_cpp.debuggers.variables.description": "此启动配置中的递归替换变量。每个变量可以引用其他变量。",
    "c_cpp.debuggers.variables.properties.description": "此启动配置中的递归替换变量。值可以引用其他变量。",
    "c_cpp.debuggers.host.description": "主机信息。",
    "c_cpp.debuggers.host.user.description": "登录到主机的用户。",
    "c_cpp.debuggers.host.hostName.description": "主机名。",
    "c_cpp.debuggers.host.port.description": "主机上的 SSH 端口。默认值为 22。",
    "c_cpp.debuggers.host.jumpHost.description": "通过首先连接到跳转主机连接到目标主机。",
    "c_cpp.debuggers.host.localForward.description": "将本地（客户端）主机上的给定 TCP 端口或 Unix 套接字的连接转发到远程端的给定主机和端口或 Unix 套接字",
    "c_cpp.debuggers.host.localForward.bindAddress.description": "本地地址",
    "c_cpp.debuggers.host.localForward.port.description": "本地端口",
    "c_cpp.debuggers.host.localForward.host.description": "主机名",
    "c_cpp.debuggers.host.localForward.hostPort.description": "主机端口",
    "c_cpp.debuggers.host.localForward.localSocket.description": "本地套接字",
    "c_cpp.debuggers.host.localForward.remoteSocket.description": "远程套接字",
    "c_cpp.debuggers.deploySteps.description": "部署应用程序所需的步骤。顺序很重要。",
    "c_cpp.debuggers.deploySteps.copyFile.description": "使用 SCP 或 rsync 复制文件。",
    "c_cpp.debuggers.deploySteps.copyFile.files.description": "要复制的文件。支持路径模式。",
    "c_cpp.debuggers.deploySteps.copyFile.targetDir.description": "目标目录。",
    "c_cpp.debuggers.deploySteps.copyFile.recursive.description": "如果为 true，则递归复制文件夹。",
    "c_cpp.debuggers.deploySteps.copyFile.scpPath.description": "SCP 的可选完整路径。如果未指定，假定 SCP 在 PATH 中",
    "c_cpp.debuggers.deploySteps.copyFile.rsyncPath.description": "rsync 的可选完整路径。如果未指定，假定 rsync 在 PATH 中",
    "c_cpp.debuggers.deploySteps.debug": "如果为 true，则在不调试的情况下启动时跳过。如果为 false，则在调试时跳过。如果未定义，则永远不跳过。",
    "c_cpp.debuggers.deploySteps.ssh.description": "SSH 命令步骤。",
    "c_cpp.debuggers.deploySteps.ssh.command.description": "通过 SSH 执行的命令。SSH 命令中的 '-c' 之后的命令。",
    "c_cpp.debuggers.deploySteps.ssh.sshPath.description": "SSH 的可选完整路径。如果未指定，假定 SSH 在 PATH 中",
    "c_cpp.debuggers.deploySteps.continueOn.description": "输出中的可选完成模式。当在输出中看到此模式时，无论此步骤是否返回，都继续部署程序。",
    "c_cpp.debuggers.deploySteps.shell.description": "Shell 命令步骤。",
    "c_cpp.debuggers.deploySteps.shell.command.description": "要执行的 Shell 命令。",
    "c_cpp.debuggers.vsCodeCommand.description": "要调用的 VS Code 命令。可以是 VS Code 中的命令或活动扩展。",
    "c_cpp.debuggers.vsCodeCommand.command.description": "要调用的 VS Code 命令。",
    "c_cpp.debuggers.vsCodeCommand.args.description": "VS Code 命令的参数。",
    "c_cpp.debuggers.sourceFileMap.sourceFileMapEntry.description": "相同源代码树的当前路径和编译时路径。在 EditorPath 下找到的文件将映射到 CompileTimePath 路径以进行断点匹配，并在显示堆栈跟踪位置时从 CompileTimePath 映射到 EditorPath。",
    "c_cpp.debuggers.sourceFileMap.sourceFileMapEntry.editorPath.description": "编辑器将使用的源代码树的路径。",
    "c_cpp.debuggers.sourceFileMap.sourceFileMapEntry.useForBreakpoints.description": "如果此条目仅用于堆栈帧位置映射，则为 False。如果此条目也应在指定断点位置时使用，则为 True。",
    "c_cpp.debuggers.symbolOptions.description": "控制如何查找和加载符号（.pdb 文件）的选项。",
    "c_cpp.debuggers.unknownBreakpointHandling.description": "控制在命中时如何处理外部设置的断点（通常通过原始 GDB 命令）。\n允许的值为 \"throw\"，其行为就像应用程序抛出异常一样，和 \"stop\"，其仅暂停调试会话。默认值为 \"throw\"。",
    "c_cpp.debuggers.VSSymbolOptions.description": "提供配置以定位和加载符号到调试适配器。",
    "c_cpp.debuggers.VSSymbolOptions.searchPaths.description": "符号服务器 URL（例如：http\u200b://MyExampleSymbolServer）或目录（例如：/build/symbols）的数组，用于搜索 .pdb 文件。这些目录将被搜索，除了默认位置 - 模块旁边和最初放置 pdb 的路径。",
    "c_cpp.debuggers.VSSymbolOptions.searchMicrosoftSymbolServer.description": "如果为 'true'，则 Microsoft 符号服务器（https\u200b://msdl.microsoft.com\u200b/download/symbols）将添加到符号搜索路径中。如果未指定，此选项默认为 'false'。",
    "c_cpp.debuggers.VSSymbolOptions.cachePath.description": "从符号服务器下载的符号应缓存的目录。如果未指定，在 Windows 上调试器将默认为 %TEMP%\\SymbolCache。",
    "c_cpp.debuggers.VSSymbolOptions.moduleFilter.description": "提供控制调试器将尝试加载符号（.pdb 文件）的模块（.dll 文件）的选项。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.description": "提供加载符号到调试适配器的配置。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.mode.description": "控制模块过滤器运行的两种基本模式中的哪一种。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.mode.loadAllButExcluded.enumDescriptions": "为所有模块加载符号，除非该模块在 'excludedModules' 数组中。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.mode.loadOnlyIncluded.enumDescriptions": "除非模块在 'includedModules' 数组中，或者通过 'includeSymbolsNextToModules' 设置包含，否则不要尝试为任何模块加载符号。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.excludedModules.description": "调试器不应加载符号的模块数组。支持通配符（例如：MyCompany.*.dll）。\n\n除非 'mode' 设置为 'loadAllButExcluded'，否则此属性将被忽略。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.includedModules.description": "调试器应加载符号的模块数组。支持通配符（例如：MyCompany.*.dll）。\n\n除非 'mode' 设置为 'loadOnlyIncluded'，否则此属性将被忽略。",
    "c_cpp.debuggers.VSSymbolOptionsModuleFilter.includeSymbolsNextToModules.description": "如果为 true，对于不在 'includedModules' 数组中的任何模块，调试器仍将检查模块本身和启动可执行文件旁边，但不会检查符号搜索列表中的路径。此选项默认为 'true'。\n\n除非 'mode' 设置为 'loadOnlyIncluded'，否则此属性将被忽略。",
    "c_cpp.debuggers.logging.natvisDiagnostics.description": "可选标志，用于确定是否应将诊断 natvis 消息记录到调试控制台。默认值为 None。",
    "c_cpp.debuggers.logging.category.verbose.description": "用于开发过程中交互式调查的日志。这些日志主要应包含对调试有用的信息，并且没有长期价值。",
    "c_cpp.debuggers.logging.category.warning.description": "记录在应用程序流程中突出显示的异常或意外事件，但不会导致应用程序执行停止。",
    "c_cpp.debuggers.logging.category.error.description": "记录在当前执行流程因故障而停止时的日志。这些日志应指示当前活动中的故障，而不是应用程序范围的故障。",
    "c_cpp.debuggers.logging.category.none.description": "不用于写入日志消息。指定日志类别不应写入任何消息。",
    "refresh.process.list.tooltip": "刷新进程列表",
    "attach.to.process": "附加到进程",
    "select.process.attach": "选择要附加的进程",
    "process.not.selected": "未选择进程。",
    "debugger.path.and.server.address.required": "调试配置中的 {0} 需要 {1} 和 {2}",
    "no.pipetransport.useextendedremote": "选择的调试配置不包含 {0} 或 {1}",
    "pipe.failed": "管道传输获取操作系统和进程失败。",
    "no.process.list": "传输附加无法获取进程列表。",
    "failed.to.make.gdb.connection": "建立 GDB 连接失败：'{0}'。",
    "failed.to.parse.processes": "解析进程失败：'{0}'。",
    "os.not.supported": "不支持的操作系统：'{0}'。",
    "timeout.processList.spawn": "'{0}' 在 {1} 秒后超时。",
    "cancel.processList.spawn": "'{0}' 已取消。",
    "error.processList.spawn": "'{0}' 以代码：'{1}' 退出。",
    "failed.processList.spawn": "启动 '{0}' 失败。",
    "process.exited": "进程以代码 {0} 退出",
    "process.succeeded": "进程执行成功。",
    "ignoring.lines.in.envfile": "忽略 {0} {1} 中无法解析的行："
}